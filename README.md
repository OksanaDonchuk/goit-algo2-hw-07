# goit-algo2-hw-07

**Design and Analysis of Algorithms. HW 7. Cache management algorithms**

## Завдання 1. Оптимізація доступу до даних за допомогою LRU-кешу

Реалізуйте програму для оптимізації обробки запитів до масиву чисел за допомогою `LRU-кешу`.

**Технічні умови**

1. Дано масив розміром `N`, який складається з позитивних цілих чисел `(1 ≤ N ≤ 100_000)`. Потрібно обробити `Q` запитів `(1 ≤ Q ≤ 50_000)` такого типу:

- `Range(L, R)` — знайти суму елементів на відрізку від індексу `L` до `R` включно.
- `Update(index, value)` — замінити значення елемента в масиві за індексом `index` на нове значення `value`.

2. Реалізуйте чотири функції для роботи з масивом:

- `range_sum_no_cache(array, L, R)`
  Функція має обчислювати суму елементів масиву на відрізку від `L` до `R` включно **без використання кешу**. Для кожного запиту результат має обчислюватися заново.

- `update_no_cache(array, index, value)`
  Функція має оновлювати значення елемента масиву за вказаним індексом **без використання кешу**.

- `range_sum_with_cache(array, L, R)`
  Функція має обчислювати суму елементів на відрізку від `L` до `R` включно, використовуючи **LRU-кеш**. Якщо сума для цього відрізку вже була обчислена раніше, вона має повертатися з кешу, інакше результат обчислюється та додається в кеш.

- `update_with_cache(array, index, value)`
  Функція має оновлювати значення елемента масиву за вказаним індексом і видаляти всі відповідні значення з кешу, які стали неактуальними через зміну в масиві.

3. Для тестування програми створіть масив розміром `100_000` елементів, заповнених випадковими числами, і згенеруйте `50_000` запитів типу `Range` та `Update` у випадковому порядку.

Приклад списку запитів: `[('Range', 46943, 91428), ('Range', 5528, 29889), ('Update', 77043, 78), ...]`

4. Використовуйте `LRU-кеш` розміром `K = 1000` для зберігання попередньо обчислених результатів запитів типу `Range`. Кеш повинен автоматично видаляти найменш недавно використані елементи, якщо досягається його максимальний розмір.

5. Здійсніть порівняння часу виконання запитів:

- Без використання кешу.
- З використанням LRU-кешу.

Виведіть результати у вигляді часу виконання для обох підходів.

**Приклад виведення в термінал виконання програми**

```
Час виконання без кешування: 3.11 секунд
Час виконання з LRU-кешем: 0.02 секунд
```

**Результат**

```
Кількість Range-запитів: 45015
Кількість Update-запитів: 4985
Час виконання без кешування: 5.01 секунд
Час виконання з LRU-кешем: 4.74 секунд
```

Час виконання з `LRU-кешем` менше, ніж `без кешування`, що показує його більш продуктивним.

## Завдання 2. Порівняння продуктивності обчислення чисел Фібоначчі із використанням LRU-кешу та Splay Tree

Реалізуйте програму для обчислення чисел Фібоначчі двома способами: із використанням `LRU-кешу` та з використанням `Splay Tree` для збереження попередньо обчислених значень. Проведіть порівняльний аналіз їхньої ефективності, вимірявши середній час виконання для кожного з підходів.

**Технічні умови**

1. Реалізуйте дві функції для обчислення чисел Фібоначчі:

- `fibonacci_lru(n)`
  Функція має використовувати декоратор `@lru_cache` для кешування результатів обчислень. Завдяки цьому вона може повторно використовувати попередньо обчислені значення чисел Фібоначчі.

- `fibonacci_splay(n, tree)`
  Функція використовує структуру даних `Splay Tree` для збереження обчислених значень. Якщо число Фібоначчі для заданого `n` уже було обчислене, значення має повертатися з дерева, інакше значення обчислюється, зберігається у `Splay Tree` і повертається.

2. Виміряйте час виконання обчислення чисел Фібоначчі для кожного з підходів:

- Створіть набір чисел Фібоначчі від 0 до 950 з кроком 50: 0, 50, 100, 150, ....
- Використовуйте модуль `timeit` для вимірювання часу виконання обчислень.
- Для кожного значення `n` обчисліть середній час виконання обчислення числа Фібоначчі з використанням `LRU-кешу` та `Splay Tree`.

3. Побудуйте графік, який порівнює час виконання для двох підходів:

- Використовуйте бібліотеку `matplotlib` для побудови графіка.
- На осі `x` відобразіть значення `n` — номер числа Фібоначчі.
- На осі `y` — середній час виконання в секундах.
- Додайте на графік легенду, яка вказує на два підходи: `LRU Cache` та `Splay Tree`.

4. Зробіть висновки щодо ефективності обох підходів на основі отриманого графіка.

5. Додатково до побудови графіка виведіть текстову таблицю, яка містить значення `n`, середній час виконання для `LRU Cache` та `Splay Tree`. Таблиця повинна бути відформатована для зручного читання.

**Результат**

| n   | LRU Cache час (с) | Splay Tree час (с) |
| --- | ----------------- | ------------------ |
| 0   | 0.0000002800      | 0.0000001700       |
| 50  | 0.0000025100      | 0.0000060800       |
| 100 | 0.0000016100      | 0.0000094100       |
| 150 | 0.0000012900      | 0.0000204500       |
| 200 | 0.0000015300      | 0.0000232000       |
| 250 | 0.0000013000      | 0.0000316500       |
| 300 | 0.0000016700      | 0.0000370000       |
| 350 | 0.0000017300      | 0.0000451800       |
| 400 | 0.0000015200      | 0.0000507700       |
| 450 | 0.0000016500      | 0.0000556000       |
| 500 | 0.0000017500      | 0.0000644600       |
| 550 | 0.0000019500      | 0.0000813500       |
| 600 | 0.0000018900      | 0.0000992600       |
| 650 | 0.0000020000      | 0.0000903700       |
| 700 | 0.0000033800      | 0.0001007100       |
| 750 | 0.0000018200      | 0.0000983200       |
| 800 | 0.0000017000      | 0.0001026600       |
| 850 | 0.0000018600      | 0.0001122300       |
| 900 | 0.0000018600      | 0.0001173800       |

### Висновок

Метод LRU Cache демонструє значно кращу продуктивність для великих значень n у порівнянні зі Splay Tree. Це пояснюється тим, що LRU Cache використовує механізм хешування для миттєвого доступу до вже обчислених значень, що зменшує накладні витрати. Натомість Splay Tree щоразу виконує операції ротації для переміщення вузлів ближче до кореня, що хоч і покращує доступ до часто використовуваних значень, все ж додає додаткові обчислювальні витрати.

Таким чином, LRU Cache є більш оптимальним вибором для завдань, де часто повторюються однакові запити, оскільки забезпечує швидший доступ до кешованих значень. Splay Tree може бути корисним у сценаріях, де структура запитів змінюється і важливо підтримувати баланс між швидкістю доступу та адаптивністю.
